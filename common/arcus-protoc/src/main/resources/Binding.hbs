////////////////////////////////////////////////////////////////////////////////
// This file has been generated by the Iris Protocol Compiler. To change
// this file please change the underlying IRP file.
////////////////////////////////////////////////////////////////////////////////

package {{package}};

import java.nio.ByteOrder;
import java.util.HashMap;
import java.util.Map;

import com.arcussmarthome.driver.groovy.zigbee.ClusterBinding;
import com.arcussmarthome.driver.groovy.zigbee.ClusterDescriptor;
import com.arcussmarthome.driver.groovy.zigbee.MessageDecoder;
import com.arcussmarthome.driver.groovy.zigbee.MessageDescriptor;
import com.arcussmarthome.driver.groovy.zigbee.ZigbeeContext;
import com.arcussmarthome.protocol.Protocol;
import com.arcussmarthome.protocol.zigbee.msg.ZigbeeMessage;
import com.arcussmarthome.protocol.zigbee.{{subpackage}}.General.*;
import com.arcussmarthome.protocol.zigbee.{{subpackage}}.{{classname}};
import com.arcussmarthome.protocol.zigbee.{{subpackage}}.{{classname}}.*;

public class {{classname}}Binding extends {{#if hasClusterId}}GeneralBinding{{else}}ClusterBinding{{/if}} {
   static {
      {{#constants}}
      constants.put("{{name}}", {{classname}}.{{name}});
      {{/constants}}
   }
   
   public {{classname}}Binding() {
      super(null);
   }
   
   public {{classname}}Binding(ZigbeeContext.Endpoint endpoint) {
      super(endpoint);
   }
   
   @Override
   public short getId() {
      {{#if hasClusterId}}
      return {{classname}}.CLUSTER_ID;
      {{else}}
      throw new UnsupportedOperationException("Cluster Id not available for this binding.");
      {{/if}}
   }
   
   @Override
   public String getName() {
      return "{{classname}}";
   }
   
   {{#structs}}
      {{#hasMessageId}}
      
      {{>MethodBinding}}
      
      {{/hasMessageId}}
   {{/structs}}
   
   public static class Factory implements ClusterBinding.Factory {
      public ClusterBinding create(ZigbeeContext.Endpoint endpoint) {
         return new {{classname}}Binding(endpoint);
      }
   }
   
   public static class Decoder implements MessageDecoder {
      private static Decoder decoder = new Decoder();
      
      public static Decoder instance() {
         return decoder;
      }
      
      private Decoder() {}

      @Override
      public Object decodeClientMessage(int messageId, byte[] bytes, ByteOrder byteOrder) {
         switch(messageId) {
         {{#structs}}
         {{#hasMessageId}}
         {{#isClient}}
         case {{../classname}}.{{classname}}.ID:
            return {{../classname}}.{{classname}}.serde().fromBytes(byteOrder, bytes);
         {{/isClient}}
         {{/hasMessageId}}
         {{/structs}}
         }
         return null;
      }
      
      @Override
      public Object decodeServerMessage(int messageId, byte[] bytes, ByteOrder byteOrder) {
         switch(messageId) {
         {{#structs}}
         {{#hasMessageId}}
         {{#isServer}}
         case {{../classname}}.{{classname}}.ID:
            return {{../classname}}.{{classname}}.serde().fromBytes(byteOrder, bytes);
         {{/isServer}}
         {{/hasMessageId}}
         {{/structs}}
         }
         return null;
      }
      
      @Override
      public Object decodeGeneralMessage(int messageId, byte[] bytes, ByteOrder byteOrder) {
         switch(messageId) {
         {{#structs}}
         {{#hasMessageId}}
         {{#isGeneral}}
         case {{../classname}}.{{classname}}.ID:
            return {{../classname}}.{{classname}}.serde().fromBytes(byteOrder, bytes);
         {{/isGeneral}}
         {{/hasMessageId}}
         {{/structs}}
         }
         return null;
      }
   }
   
   public static class Descriptor implements ClusterDescriptor {
      private static Map<String, MessageDescriptor> messagesByName = new HashMap<>();
      private static Descriptor descriptor = new Descriptor();
      
      static {
         {{#structs}}{{#hasMessageId}}
         messagesByName.put("{{toLowerCase classname}}", new MessageDescriptor({{../classname}}.{{classname}}.ID, {{#if ../../hasClusterId}}true{{else}}false{{/if}}, "{{group}}"));
         {{/hasMessageId}}{{/structs}}
      }
      
      public static Descriptor instance() {
         return descriptor;
      }
      
      private Descriptor() {}

      @Override
      public short getId() {
         {{#if hasClusterId}}
         return {{classname}}.CLUSTER_ID;
         {{else}}
         throw new UnsupportedOperationException("Cluster Id not available for this binding.");
         {{/if}}
      }

      @Override
      public String getName() {
         return "{{classname}}";
      }

      @Override
      public MessageDescriptor getMessageByName(String commandName) {
         MessageDescriptor message = messagesByName.get(commandName);
         {{#if hasClusterId}}
         return message != null ? message : GeneralBinding.Descriptor.instance().getMessageByName(commandName);
         {{else}}
         return message;
         {{/if}}
      }
   }
}